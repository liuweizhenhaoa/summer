**现状：**
目前数据量比较大的表：
trip（行程表）、
分表字段，用户id（采用用户id预hash）


技术选型：
目前是比较流行的技术解决方案有mycat和sharding-jdbc
1、mycat:
是基于 Proxy，它复写了 MySQL 协议，将 Mycat Server 伪装成一个 MySQL 数据库
2、Sharding-JDBC:
基于 JDBC 接口的扩展，无需额外的proxy，因此也无需关注proxy本身的高可用,，以 jar 包的形式提供轻量级服务的。
Sharding-JDBC直接封装JDBC API，可以理解为增强版的JDBC驱动，旧代码迁移成本几乎为零：
可适用于任何基于java的ORM框架，如：JPA, Hibernate, Mybatis, Spring JDBC Template或直接使用JDBC。
可基于任何第三方的数据库连接池，如：DBCP, C3P0, BoneCP, Druid等。
理论上可支持任意实现JDBC规范的数据库。虽然目前仅支持MySQL，但已有支持Oracle，SQLServer，DB2等数据库的计划。
开源现状：mycat目前不更新也不修复BUG，sharding-jdbc目前一直在维护和更新，社区比较活跃，并且对spring的支持比较好。

最终综合考虑：sharding-jdbc


数据分表规则的一些考虑：
前面的例子，演示的是根据entity_key进行分表，也可以使用其他字段如主键进行分表。以下是我想到的一些分表规则：
根据主键进行分配
这种方式能够实现最平均的分配方法，每生成一条新数据，会依次保存到下一个数据表中。
根据用户ID进行分配
这种方式能够确保同一个用户的所有数据保存在同一个数据表中。如果经常按用户id查询数据，这是比较经济的一种做法。
根据某一个外键的值进行分配
前面的例子采用的就是这种方法，因为这个数据可能会经常根据这个外键进行查询。
根据时间进行分配
适用于一些经常按时间段进行查询的数据，将一个时间段内的数据保存在同一个数据表中。比如订单系统，缺省查询一个月之内的数据。

基于我们当前系统的思考：
1、按照时间去拆分，例如：每3个月一张表
问题：插入数据的时候能路由到对应的表，但是当查询的时候需要带上对应的时间，这个时间不能确定，所以这种分表策略有问题。
2、按照用户id  哈希去拆分
查询：查询的时候都带上用户id，这个是没有问题。
新增：插入数据的时候都带有用户id，ok
修改：修改数据的时候带有用户id，ok
3、取模或者range(范围分片)
目前，主键id（uuid）或者用户id不是数字类型，所以无法进行该分表分库策略


目前的问题：
由于要整合第三方开源的分表分库中间件，需要和我们当前的框架进行整合。
我们框架目前的：框架数据源，jdbctemplate和Datautil绑定，导致如果要整合第三方分表分库中间件的话，需要对框架进行改造。而第三方数据源和连接池等都交给spring容器进行管理。
分表分库之后带来的主键唯一问题。在分表后多个表之间的主键保持唯一性？

分库分表后历史数据的处理：
根据数据分表的规则，需要对原有数据包的数据进行迁移，分别移动到四个数据表中。如果不做这一步，或者数据迁移到了错误的数据表，后续将会查询不到这些数据。
至此，对项目的修改基本完成，重新启动项目并增加operate_history数据，就会看到新添加的数据，已经根据我们的分表规则，插入到了某一个数据表中。查询的时候，能够同时查询到多个实际数据表中的数据。


受影响的模块：
首先是和分表对应表的统计模块。拿trip表来说，对应的行程统计模块需要改造。以前统计是从单张表统计，分表之后的统计需要改造（1、增量统计：新增一条数据 2、全量统计：将行程汇总，然后进行统计）。

后期关于统计的怎么进行？
初步设想：
1、将数据同步到hbase,然后在同一进行统计。
2、数据在倒入ES,提供查询。


场景一：分库分表假如按uid分库分表，那么按uname查询怎么办？
用户中心是每一个公司必备的基础服务，用户的注册，登录，信息查询都离不开用户中心。当数据量越来越大的时候，需要多用户进行水平切分。最常见的水平切分方式，按照uid取膜分库，通过取膜将数据分布到多个数据库实例，提高服务实例个数，已达到扩容的目的。
如果按照uid查询可以直接路由到库。如图水平切分之后：


假如 uid=121,取膜之后直接定位到db1
如果是uname查询，假设uname=hello，就没有办法定位到库了。
如果想要高效的查询，今天主要讨论两种方案。
1.【索引表方法】
思路：uid可以直接定位到库，uname不能直接定位到库，如果能通过uname 定位到 uid那么为问题解决。下面来说下怎么通过uid定位到uname
解决方案：
1)建立一个索引记录表，映射关系uname 对应 uid。并且建立索引
2）当用uname查询时，先通过uname查询到uid，在定位到库
3）索引表数据属性少，可以容纳很多数据，一般不需要分库
4）如果数据量过大可以按uname分库
缺点：多一次数据库的查询，性能下降一半
2【缓存映射方法】
思路：访问索引表性能低，把映射关系放到缓存中
解决方案：
1）通过uname先查到缓存与uname的对应关系uid
uname和uid关系不会变化，因为uname和uid都是唯一的
缺点：多一次缓存查询



